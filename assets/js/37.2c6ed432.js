(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{284:function(e,t,r){"use strict";r.r(t);var o=r(28),v=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[r("strong",[r("code",[e._v("computed")]),e._v(" 本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的 "),r("code",[e._v("getter")]),e._v("，而不是用户定义的方法。 "),r("code",[e._v("computed")]),e._v(" 内部实现了一个惰性的 "),r("code",[e._v("watcher")]),e._v("，在实例化的时候不会去求值，其内部通过 "),r("code",[e._v("dirty")]),e._v(" 属性标记计算属性是否需要重新求值。当 "),r("code",[e._v("computed")]),e._v(" 依赖的任一状态（不一定是 "),r("code",[e._v("return")]),e._v(" 中的）发生变化，都会通知这个惰性 "),r("code",[e._v("watcher")]),e._v("，让它把 "),r("code",[e._v("dirty")]),e._v(" 属性设置为 "),r("code",[e._v("true")]),e._v("。所以当再次读取这个计算属性的时候，就会去重新求值。惰性 "),r("code",[e._v("watcher")]),e._v("/计算属性在创建时是不会去求值的，是在使用的时候去求值的。")])]),e._v(" "),r("h2",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/291",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue中computed是如何实现的"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=v.exports}}]);