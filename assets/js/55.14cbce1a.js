(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{314:function(t,a,r){"use strict";r.r(a);var e=r(28),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"什么是virtual-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是virtual-dom"}},[t._v("#")]),t._v(" 什么是Virtual DOM")]),t._v(" "),r("p",[t._v("Virtual DOM 是对 DOM 的抽象，本质上是JavaScript对象，这个对象就是更加轻量级的对DOM的描述。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.loli.net/2020/07/27/LkstnuvOR3NJzGi.png",alt:"Virtual DOM"}})]),t._v(" "),r("h2",{attrs:{id:"为什么需要virtual-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要virtual-dom"}},[t._v("#")]),t._v(" 为什么需要Virtual DOM")]),t._v(" "),r("p",[r("strong",[t._v("前端性能优化的一个秘诀在于：尽可能少的操作DOM，因为频繁操作DOM会造成浏览器的回流或者重回。需要额外增加一层抽象（Virtual DOM）有利于在 patch 过程中尽可能地一次性将差异更新到 DOM 中，保证DOM不会出现性能很差的情况。同时 Virtual DOM 最初的目的就是更好的跨平台，如 Node.js 没有 DOM，如果想实现 SSR（服务端渲染），就需要借助 Virtual DOM，因为 Virtual DOM 本身是 JavaScript 对象。")])]),t._v(" "),r("h2",{attrs:{id:"virtual-dom-的diff"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-的diff"}},[t._v("#")]),t._v(" Virtual DOM 的diff")]),t._v(" "),r("p",[t._v("时间复杂度为 O(n)，同级比较 DOM 差异。")]),t._v(" "),r("h2",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://juejin.im/post/5d3f3bf36fb9a06af824b3e2",target:"_blank",rel:"noopener noreferrer"}},[t._v("面试官：你对虚拟DOM原理的理解？"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5d42e5036fb9a06b0d7c66b0",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue原理解析（五）：彻底搞懂虚拟DOM到真实DOM的生成过程"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=i.exports}}]);