(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{321:function(a,e,t){"use strict";t.r(e);var r=t(28),v=Object(r.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"什么是-webpack？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-webpack？"}},[a._v("#")]),a._v(" 什么是 webpack？")]),a._v(" "),t("blockquote",[t("p",[a._v("webpack 是一个现代 JavaScript 应用程序的静态模块打包器（module bundler）。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。")])]),a._v(" "),t("p",[a._v("webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。")]),a._v(" "),t("p",[a._v("webpack 通过 Tapable 来组织这条复杂的生产线。webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。")]),a._v(" "),t("h2",{attrs:{id:"webpack-核心概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-核心概念"}},[a._v("#")]),a._v(" webpack 核心概念")]),a._v(" "),t("h3",{attrs:{id:"entry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#entry"}},[a._v("#")]),a._v(" Entry")]),a._v(" "),t("p",[t("strong",[a._v("入口起点（entry point）指示 webpack 应该使用哪个模块来作为构建其内部依赖图的开始。")]),a._v("\n进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和简洁）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。")]),a._v(" "),t("h3",{attrs:{id:"output"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#output"}},[a._v("#")]),a._v(" Output")]),a._v(" "),t("p",[a._v("output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。（基本上整个应用程序结构，都会被编译到你指定的输出路径的文件夹中）")]),a._v(" "),t("h3",{attrs:{id:"module"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[a._v("#")]),a._v(" Module")]),a._v(" "),t("p",[a._v("模块：在 webpack 里一切皆为模块，一个模块对应着一个文件。webpack 会从配置的 Entry 开始递归找出所有依赖的模块。")]),a._v(" "),t("h3",{attrs:{id:"chunk"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#chunk"}},[a._v("#")]),a._v(" Chunk")]),a._v(" "),t("p",[a._v("代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。")]),a._v(" "),t("h3",{attrs:{id:"loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader"}},[a._v("#")]),a._v(" Loader")]),a._v(" "),t("p",[t("strong",[a._v("loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，这样就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。")])]),a._v(" "),t("h3",{attrs:{id:"plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[a._v("#")]),a._v(" Plugin")]),a._v(" "),t("p",[a._v("插件可以用于执行范围更广的任务。插件的范围包括：从打包优化和压缩一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。")]),a._v(" "),t("h2",{attrs:{id:"webpack-构建流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-构建流程"}},[a._v("#")]),a._v(" webpack 构建流程")]),a._v(" "),t("p",[a._v("Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")]),a._v(" "),t("ul",[t("li",[a._v("初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。")]),a._v(" "),t("li",[a._v("开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。")]),a._v(" "),t("li",[a._v("确定入口：根据配置中的 entry 找出所有的入口文件。")]),a._v(" "),t("li",[a._v("编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。")]),a._v(" "),t("li",[a._v("完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。")]),a._v(" "),t("li",[a._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。")]),a._v(" "),t("li",[a._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。")])]),a._v(" "),t("p",[t("strong",[a._v("以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。")])]),a._v(" "),t("h2",{attrs:{id:"编译阶段（babel作用）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译阶段（babel作用）"}},[a._v("#")]),a._v(" 编译阶段（babel作用）")]),a._v(" "),t("h3",{attrs:{id:"解析入口文件，获取-ast-抽象语法树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析入口文件，获取-ast-抽象语法树"}},[a._v("#")]),a._v(" 解析入口文件，获取 AST 抽象语法树")]),a._v(" "),t("p",[a._v("通过 "),t("code",[a._v("@babel/parser")]),a._v(" 来分析内部的语法（包括 es6），返回一个 AST 抽象语法树。")]),a._v(" "),t("h3",{attrs:{id:"找出所有依赖模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#找出所有依赖模块"}},[a._v("#")]),a._v(" 找出所有依赖模块")]),a._v(" "),t("p",[a._v("通过 "),t("code",[a._v("@babel/traverse")]),a._v(" 遍历 AST 语法树，找出依赖模块。")]),a._v(" "),t("h3",{attrs:{id:"ast-转换为-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ast-转换为-code"}},[a._v("#")]),a._v(" AST 转换为 code")]),a._v(" "),t("p",[a._v("通过 "),t("code",[a._v("@babel/core")]),a._v("、"),t("code",[a._v("@babel/preset-env")]),a._v(" 将 AST 语法树转换为浏览器可执行代码。")]),a._v(" "),t("h2",{attrs:{id:"参考文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[a._v("#")]),a._v(" 参考文章")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/5e116fce6fb9a047ea7472a6",target:"_blank",rel:"noopener noreferrer"}},[a._v("webpack打包原理？看完这篇你就懂了！"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/44438844",target:"_blank",rel:"noopener noreferrer"}},[a._v("关于webpack的面试题总结"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/30669007",target:"_blank",rel:"noopener noreferrer"}},[a._v("Webpack HMR 原理解析"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=v.exports}}]);